// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"time"
)

const deleteCapture = `-- name: DeleteCapture :exec
DELETE FROM captures
WHERE id = ?
`

func (q *Queries) DeleteCapture(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteCapture, id)
	return err
}

const getCapturesForArchive = `-- name: GetCapturesForArchive :many
SELECT id, file_path, file_size
FROM captures
WHERE archived = 0
  AND capture_datetime < datetime('now', ?)
ORDER BY capture_datetime ASC
`

type GetCapturesForArchiveRow struct {
	ID       int64
	FilePath string
	FileSize int64
}

func (q *Queries) GetCapturesForArchive(ctx context.Context, datetime interface{}) ([]GetCapturesForArchiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getCapturesForArchive, datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCapturesForArchiveRow
	for rows.Next() {
		var i GetCapturesForArchiveRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.FileSize); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCapturesForArchiveWithLimit = `-- name: GetCapturesForArchiveWithLimit :many
SELECT id, file_path
FROM captures
WHERE archived = 0
  AND capture_datetime < datetime('now', ?)
ORDER BY capture_datetime ASC
`

type GetCapturesForArchiveWithLimitRow struct {
	ID       int64
	FilePath string
}

func (q *Queries) GetCapturesForArchiveWithLimit(ctx context.Context, datetime interface{}) ([]GetCapturesForArchiveWithLimitRow, error) {
	rows, err := q.db.QueryContext(ctx, getCapturesForArchiveWithLimit, datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCapturesForArchiveWithLimitRow
	for rows.Next() {
		var i GetCapturesForArchiveWithLimitRow
		if err := rows.Scan(&i.ID, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getConfig = `-- name: GetConfig :one
SELECT watch_dir, organized_dir, archive_dir, expose_service, port, compression_enabled, archive_days, max_retention_days, log_level FROM config LIMIT 1
`

func (q *Queries) GetConfig(ctx context.Context) (Config, error) {
	row := q.db.QueryRowContext(ctx, getConfig)
	var i Config
	err := row.Scan(
		&i.WatchDir,
		&i.OrganizedDir,
		&i.ArchiveDir,
		&i.ExposeService,
		&i.Port,
		&i.CompressionEnabled,
		&i.ArchiveDays,
		&i.MaxRetentionDays,
		&i.LogLevel,
	)
	return i, err
}

const getOldArchivedCaptures = `-- name: GetOldArchivedCaptures :many
SELECT id, file_path
FROM captures
WHERE archived = 1
  AND capture_datetime < datetime('now', ?)
ORDER BY capture_datetime ASC
`

type GetOldArchivedCapturesRow struct {
	ID       int64
	FilePath string
}

func (q *Queries) GetOldArchivedCaptures(ctx context.Context, datetime interface{}) ([]GetOldArchivedCapturesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOldArchivedCaptures, datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOldArchivedCapturesRow
	for rows.Next() {
		var i GetOldArchivedCapturesRow
		if err := rows.Scan(&i.ID, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCompressions = `-- name: GetPendingCompressions :many
SELECT id, file_path, file_size
FROM captures
WHERE compressed = 0
  AND archived = 0
ORDER BY capture_datetime ASC
LIMIT ?
`

type GetPendingCompressionsRow struct {
	ID       int64
	FilePath string
	FileSize int64
}

func (q *Queries) GetPendingCompressions(ctx context.Context, limit int64) ([]GetPendingCompressionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCompressions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingCompressionsRow
	for rows.Next() {
		var i GetPendingCompressionsRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.FileSize); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertCapture = `-- name: InsertCapture :one
INSERT INTO captures (
    hostname,
    scenario,
    capture_datetime,
    file_path,
    file_size,
    compressed,
    archived,
    created_at,
    updated_at
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING id
`

type InsertCaptureParams struct {
	Hostname        string
	Scenario        string
	CaptureDatetime time.Time
	FilePath        string
	FileSize        int64
	Compressed      sql.NullBool
	Archived        sql.NullBool
	CreatedAt       sql.NullTime
	UpdatedAt       sql.NullTime
}

func (q *Queries) InsertCapture(ctx context.Context, arg InsertCaptureParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertCapture,
		arg.Hostname,
		arg.Scenario,
		arg.CaptureDatetime,
		arg.FilePath,
		arg.FileSize,
		arg.Compressed,
		arg.Archived,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertCaptureStats = `-- name: InsertCaptureStats :exec
INSERT INTO capture_stats (
    capture_id,
    packet_count,
    protocol_distribution,
    top_src_ips,
    top_dst_ips,
    top_tcp_src_ports,
    top_tcp_dst_ports,
    top_udp_src_ports,
    top_udp_dst_ports,
    packet_rate,
    avg_packet_size,
    duration_seconds,
    first_packet_time,
    last_packet_time
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertCaptureStatsParams struct {
	CaptureID            int64
	PacketCount          sql.NullInt64
	ProtocolDistribution sql.NullString
	TopSrcIps            sql.NullString
	TopDstIps            sql.NullString
	TopTcpSrcPorts       sql.NullString
	TopTcpDstPorts       sql.NullString
	TopUdpSrcPorts       sql.NullString
	TopUdpDstPorts       sql.NullString
	PacketRate           sql.NullFloat64
	AvgPacketSize        sql.NullFloat64
	DurationSeconds      sql.NullInt64
	FirstPacketTime      sql.NullTime
	LastPacketTime       sql.NullTime
}

func (q *Queries) InsertCaptureStats(ctx context.Context, arg InsertCaptureStatsParams) error {
	_, err := q.db.ExecContext(ctx, insertCaptureStats,
		arg.CaptureID,
		arg.PacketCount,
		arg.ProtocolDistribution,
		arg.TopSrcIps,
		arg.TopDstIps,
		arg.TopTcpSrcPorts,
		arg.TopTcpDstPorts,
		arg.TopUdpSrcPorts,
		arg.TopUdpDstPorts,
		arg.PacketRate,
		arg.AvgPacketSize,
		arg.DurationSeconds,
		arg.FirstPacketTime,
		arg.LastPacketTime,
	)
	return err
}

const markCaptureAsArchived = `-- name: MarkCaptureAsArchived :exec
UPDATE captures
SET archived = 1, updated_at = current_timestamp
WHERE id = ?
`

func (q *Queries) MarkCaptureAsArchived(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markCaptureAsArchived, id)
	return err
}

const markCaptureAsCompressed = `-- name: MarkCaptureAsCompressed :exec
UPDATE captures
SET compressed = 1, updated_at = current_timestamp
WHERE id = ?
`

func (q *Queries) MarkCaptureAsCompressed(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, markCaptureAsCompressed, id)
	return err
}

const updateConfig = `-- name: UpdateConfig :exec
UPDATE config
SET watch_dir = ?,
organized_dir = ?,
archive_dir = ?,
expose_service = ?,
port = ?,
compression_enabled = ?,
archive_days = ?,
max_retention_days = ?,
log_level = ?
`

type UpdateConfigParams struct {
	WatchDir           sql.NullString
	OrganizedDir       sql.NullString
	ArchiveDir         sql.NullString
	ExposeService      sql.NullBool
	Port               sql.NullInt64
	CompressionEnabled sql.NullBool
	ArchiveDays        sql.NullInt64
	MaxRetentionDays   sql.NullInt64
	LogLevel           sql.NullString
}

func (q *Queries) UpdateConfig(ctx context.Context, arg UpdateConfigParams) error {
	_, err := q.db.ExecContext(ctx, updateConfig,
		arg.WatchDir,
		arg.OrganizedDir,
		arg.ArchiveDir,
		arg.ExposeService,
		arg.Port,
		arg.CompressionEnabled,
		arg.ArchiveDays,
		arg.MaxRetentionDays,
		arg.LogLevel,
	)
	return err
}

const updateFilePath = `-- name: UpdateFilePath :exec
UPDATE captures
SET file_path = ?, updated_at = current_timestamp
WHERE id = ?
`

type UpdateFilePathParams struct {
	FilePath string
	ID       int64
}

func (q *Queries) UpdateFilePath(ctx context.Context, arg UpdateFilePathParams) error {
	_, err := q.db.ExecContext(ctx, updateFilePath, arg.FilePath, arg.ID)
	return err
}
