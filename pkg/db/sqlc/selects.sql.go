// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: selects.sql

package sqlc

import (
	"context"
)

const getCapture = `-- name: GetCapture :one
SELECT id, hostname, scenario, capture_datetime, file_path, file_size, compressed, archived, created_at, updated_at FROM captures WHERE id = ?
`

func (q *Queries) GetCapture(ctx context.Context, id int64) (Capture, error) {
	row := q.db.QueryRowContext(ctx, getCapture, id)
	var i Capture
	err := row.Scan(
		&i.ID,
		&i.Hostname,
		&i.Scenario,
		&i.CaptureDatetime,
		&i.FilePath,
		&i.FileSize,
		&i.Compressed,
		&i.Archived,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCaptures = `-- name: GetCaptures :many
SELECT id, hostname, scenario, capture_datetime, file_path, file_size, compressed, archived, created_at, updated_at FROM captures
`

func (q *Queries) GetCaptures(ctx context.Context) ([]Capture, error) {
	rows, err := q.db.QueryContext(ctx, getCaptures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Capture
	for rows.Next() {
		var i Capture
		if err := rows.Scan(
			&i.ID,
			&i.Hostname,
			&i.Scenario,
			&i.CaptureDatetime,
			&i.FilePath,
			&i.FileSize,
			&i.Compressed,
			&i.Archived,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCapturesForArchive = `-- name: GetCapturesForArchive :many

SELECT id, file_path, file_size
FROM captures
WHERE archived = 0
  AND capture_datetime < datetime('now', ?)
ORDER BY capture_datetime ASC
`

type GetCapturesForArchiveRow struct {
	ID       int64
	FilePath string
	FileSize int64
}

// Select queries
func (q *Queries) GetCapturesForArchive(ctx context.Context, datetime interface{}) ([]GetCapturesForArchiveRow, error) {
	rows, err := q.db.QueryContext(ctx, getCapturesForArchive, datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCapturesForArchiveRow
	for rows.Next() {
		var i GetCapturesForArchiveRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.FileSize); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCapturesForArchiveWithLimit = `-- name: GetCapturesForArchiveWithLimit :many
SELECT id, file_path
FROM captures
WHERE archived = 0
  AND capture_datetime < datetime('now', ?)
ORDER BY capture_datetime ASC
`

type GetCapturesForArchiveWithLimitRow struct {
	ID       int64
	FilePath string
}

func (q *Queries) GetCapturesForArchiveWithLimit(ctx context.Context, datetime interface{}) ([]GetCapturesForArchiveWithLimitRow, error) {
	rows, err := q.db.QueryContext(ctx, getCapturesForArchiveWithLimit, datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCapturesForArchiveWithLimitRow
	for rows.Next() {
		var i GetCapturesForArchiveWithLimitRow
		if err := rows.Scan(&i.ID, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOldArchivedCaptures = `-- name: GetOldArchivedCaptures :many
SELECT id, file_path
FROM captures
WHERE archived = 1
  AND capture_datetime < datetime('now', ?)
ORDER BY capture_datetime ASC
`

type GetOldArchivedCapturesRow struct {
	ID       int64
	FilePath string
}

func (q *Queries) GetOldArchivedCaptures(ctx context.Context, datetime interface{}) ([]GetOldArchivedCapturesRow, error) {
	rows, err := q.db.QueryContext(ctx, getOldArchivedCaptures, datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetOldArchivedCapturesRow
	for rows.Next() {
		var i GetOldArchivedCapturesRow
		if err := rows.Scan(&i.ID, &i.FilePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPendingCompressions = `-- name: GetPendingCompressions :many
SELECT id, file_path, file_size
FROM captures
WHERE compressed = 0
  AND archived = 0
ORDER BY capture_datetime ASC
LIMIT ?
`

type GetPendingCompressionsRow struct {
	ID       int64
	FilePath string
	FileSize int64
}

func (q *Queries) GetPendingCompressions(ctx context.Context, limit int64) ([]GetPendingCompressionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCompressions, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPendingCompressionsRow
	for rows.Next() {
		var i GetPendingCompressionsRow
		if err := rows.Scan(&i.ID, &i.FilePath, &i.FileSize); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
